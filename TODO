 * support set-if-not-exists command
 * support exists command
 * support touch command, which would load the item in the cache (without returning it)
   if the keys is not already in the cache, otherwise it would just update the last-loaded timestamp

 * implement persistent connections among peers (messaging.c doesn't support persistent connections
   at the moment but shardcache_client.c does, it might be as easy as moving the logic from 
   shardcache_client.c to messaging.c)

 * use asynchronous i/o when sending messages to peers (all functions in messaging.c)

 * make asynchronous versions of shardcache_get() and shardcache_set()
   which provide/send data in chunks while available by calling some callback
   passed as argument

 * parallelize eviction
   evict commands are very small and can be handled quickly but now it's
   only one thread making this job and it might be not enough in case of
   a big number of delete requests for keys not owned by the
   receiving instance)

 * parallelize migrations

 * refactor arc.c to get rid of the recursive lock
   the fetch logic should be taken out of arc_move() and moved to a separated function
   which can then be used also in arc_lookup() when a new object is being created because a new
   key was requested and it wasn't in the cache.
   arc_lookup must try immediately to fetch the key/value from the storage to check 
   if it exists or not ... so that it can fail early without adding a new empty object
   to the hashtable to then fail later at arc_move() when trying to fetch the value.
   The problem with such a change will be finding a way to keep fetching of the object serialized
   so that multiple threads won't try accessing the storage to fetch the same object.
   At the moment this is ensured by locking the actual object (which is inserted immediately when a new
   key is requested , so further threads will lock on that same object). If this won't be the case anymore
   we still need a way to serialize access to the storage for the same key , while still allowing parallel 
   access to different keys
