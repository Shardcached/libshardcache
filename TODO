 * parallelize eviction
   evict commands are very small and can be handled quickly but now it's
   only one thread making this job and it might be not enough in case of
   a big number of delete requests for keys not owned by the
   receiving instance)

 * parallelize migrations

 * refactor arc.c to get rid of the recursive lock
   the fetch logic should be taken out of arc_move() and moved to a separated function
   which can then be used also in arc_lookup() when a new object is being created because a new
   key was requested and it wasn't in the cache.
   arc_lookup must try immediately to fetch the key/value from the storage to check 
   if it exists or not ... so that it can fail early without adding a new empty object
   to the hashtable to then fail later at arc_move() when trying to fetch the value.
   The problem with such a change will be finding a way to keep fetching of the object serialized
   so that multiple threads won't try accessing the storage to fetch the same object.
   At the moment this is ensured by locking the actual object (which is inserted immediately when a new
   key is requested , so further threads will lock on that same object). If this won't be the case anymore
   we still need a way to serialize access to the storage for the same key , while still allowing parallel 
   access to different keys

 * assign a thread (or a pool of threads) to handle the asynchronous i/o and act as a 
   data-provider/communication-manager for the shardcache node. So that the serving threads
   would be never blocked when communicating with other peers.

 * make fetch_from_peer_async()/read_message_async() able to run an existing iomux so that
   serving.c can keep running its connections while a big data is being fetched from a peer node
