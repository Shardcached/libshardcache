The internal communication protocol may described by the following grammar:

MESSAGE      : <MSG> | <SIG_MESSAGE> | <NOOP>
MSG          : <HDR><RECORD>[<RSEP><RECORD>...]<EOM>
NOOP         : <MSG_NOP>
HDR          : <MSG_GET> | <MSG_SET> | <MSG_DEL> | <MSG_EVI> |
               <MSG_GTA> | <MSG_GTO> | <MSG_MGB> | <MSG_MGA> |
               <MSG_MGE> | <MSG_STS> | <MSG_CHK> | <MSG_IDG> |
               <MSG_IDR> | <MSG_RES>
MSG_GET      : 0x01
MSG_SET      : 0x02
MSG_DEL      : 0x03
MSG_EVI      : 0x04
MSG_MGA      : 0x21
MSG_MGB      : 0x22
MSG_MGE      : 0x23
MSG_CHK      : 0x31
MSG_STS      : 0x32
MSG_IDG      : 0x41
MSG_IDR      : 0x42
MSG_NOP      : 0x90
MSG_RES      : 0x99
RSEP         : 0x80
NULL_RECORD  : <EOR>
EOR          : <NULL_BYTE><NULL_BYTE>
RECORD       : <SIZE><DATA>[<SIZE><DATA>...]<EOR>
SIZE         : <WORD>
WORD         : <HIGH_BYTE><LOW_BYTE>
HIGH_BYTE    : <BYTE>
LOW_BYTE     : <BYTE>
DATA         : <BYTE>...<BYTE>
BYTE         : 0x00 - 0xFF
NULL_BYTE    : 0x00
EOM          : <NULL_BYTE>
KEY          : <RECORD>
VALUE        : <RECORD>
TTL          : <RECORD>
NODES_LIST   : <RECORD>
INDEX        : <RECORD>
LONGSIZE     : <HIGH_WORD><LOW_WORD>
HIGH_WORD    : <WORD>
LOW_WORD     : <WORD>

-------------------------------------------------------------------------------

The only supported messages are the following:


GET_MESSAGE  : <MSG_GET><KEY><EOM>
GET_ASYNC    : <MSG_GETA><KEY><EOM>
GET_OFFSET   : <MSG_GTO><KEY><LONG_SIZE><LONG_SIZE><EOM>
SET_MESSAGE  : <MSG_SET><KEY><RSEP><VALUE>[<RSEP><TTL>]<EOM>
DEL_MESSAGE  : <MSG_DEL><KEY><EOM>
EVI_MESSAGE  : <MSG_EVI><KEY><EOM>
RES_MESSAGE  : <MSG_RES><RECORD><EOM>

MGB_MESSAGE  : <MSG_MGB><NODES_LIST><EOM>
MGA_MESSAGE  : <MSG_MGA><NULL_RECORD><EOM>
MGE_MESSAGE  : <MSG_MGE><NULL_RECORD><EOM>

STS_MESSAGE  : <MSG_STS><NULL_RECORD><EOM>
CHK_MESSAGE  : <MSG_CHK><NULL_RECORD><EOM>

IDG_MESSAGE  : <MSG_IDG><NULL_RECORD><EOM>
IDR_MESSAGE  : <MSG_IDR><INDEX><EOM>

-------------------------------------------------------------------------------

Protocol extensions for signature/crc:

SIG_MESSAGE  : <SIG_MSG> | <CSIG_MSG>
SIG_MSG      : <SIG_HDR><MESSAGE><SIG>
CSIG_MSG     : <CSIG_HDR><HDR><CSIG><CSIG_RECORD>[<RSEP><CSIG><CSIG_RECORD>...]<EOM><CSIG>
SIG_HDR      : <HDR_SIPHASH>
CSIG_HDR     : <HDR_CSIPHASH>
HDR_SIPHASH  : 0xF0
HDR_CSIPHASH : 0xF1
CSIG_RECORD  : <SIZE><DATA><SIG>[<SIZE><DATA><SIG>...]<EOR>
SIG          : <BYTE>[8]
CSIG         : <BYTE>[8]

-------------------------------------------------------------------------------

The signature header SIG_HDR defines the signature algorithm applied and 
if chunk-signing has been used instead of  simple-signing.
The least significative bit in the SIG_HDR byte determines if chunk-signing is
enabled

- simple-signing : There is only one signature applied at the end of the message
                   and which signs the entire message as a whole.

                    <SIG_HDR><HDR><SIZE><CHUNK>[<SIZE><CHUNK>...]<EOR><EOM><SIG>
                      0xF0   |---------------------S----------------------|


- chunk-signing  : Each chunk of the message has been signed independently
                   (which allows asynchronous read/flush of big messages without
                   the need of accumulating them in-memory)

    <CSIG_HDR><HDR><SIG><SIZE><CHUNK><SIG>[<SIZE><CHUNK><SIG>...]<EOR><EOM><SIG>
       0xF1   |-S-|     |-----S-----|      |-----S-----|         |----S---|


NOTE: The actual protocol implementation supports only SIPHASH signatures.
      The SIG_HDR defined for SIPHASH is 0xF0 (0xF1 if chunk-signing).
      The SIPHASH context is unique per message also when using chunk-signing

-------------------------------------------------------------------------------

NOTE: Some commands/responses require the transmitter record to contain
      data formatted in a specific way.


The MGB_MESSAGE command expects the NODE_LIST to be conform
to the following grammar :

NODES_LIST   : <NODES_STRING>
NODES_STRING : <LABEL><:><ADDRESS><:><PORT>[<,><LABEL><:><ADDRESS><:><PORT>...]
LABEL        : <STRING>
ADDRESS      : <STRING>
PORT         : <STRING>
,            : 0x2C
:            : 0x3A
STRING       : <DATA>

The IDR_MESSAGE response returns the INDEX in the form
defined by the following grammar:

INDEX        : <KSIZE><KEY><VSIZE>[<KSIZE><KEY><VSIZE>...]<EOR>
KSIZE        : <LONGSIZE>
KEY          : <DATA>
VSIZE        : <LONGSIZE>


-------------------------------------------------------------------------------



The layout for an empty (but still valid) message would be :

===============================================================================
|  FIELD   |  SIZE   |  DESC                                                  |
|----------|---------|--------------------------------------------------------|
| SIG_HDR  | 1 Byte  |  The signature header (0xF0)                           |
|----------|---------|--------------------------------------------------------|
|   HDR    | 1 Byte  |  The message type                                      |
|----------|---------|--------------------------------------------------------|
|   EOR    | 2 Bytes |  End Of Record (0x00, 0x00)                            |
|----------|---------|--------------------------------------------------------|
|   EOM    | 1 Byte  |  Message Terminator (0x00)                             |
|----------|---------|--------------------------------------------------------|
|   SIG    | 8 Bytes |  SIPHASH digest computed on the message                |
|          |         |  using the shared secret                               |
-------------------------------------------------------------------------------

A message containing one record (fitting a single chunk) would look like :

===============================================================================
|  FIELD   |  SIZE   |  DESC                                                  |
|----------|---------|--------------------------------------------------------|
| SIG_HDR  | 1 Byte  |  The signature header (0xF0)                           |
|----------|---------|--------------------------------------------------------|
|   HDR    | 1 Byte  |  The message type                                      |
|----------|---------|--------------------------------------------------------|
|   SIZE   | 2 Bytes |  The length of the following chunk of data             |
|          |         |  (in network byte order)                               |
|----------|---------|--------------------------------------------------------|
|   DATA   | N Bytes |  The actual chunk of data                              |
|----------|---------|--------------------------------------------------------|
|   EOR    | 2 Bytes |  End Of Record (0x00, 0x00)                            |
|----------|---------|--------------------------------------------------------|
|   EOM    | 1 Byte  |  Message Terminator (0x00)                             |
|----------|---------|--------------------------------------------------------|
|   SIG    | 8 Bytes |  SIPHASH digest computed on the message                |
|          |         |  using the shared secret                               |
-------------------------------------------------------------------------------


A message containing 2 records,  for instance a 'SET' request where all
key, value and ttl need to be provided (still fitting in one chunk) :

===============================================================================
|  FIELD   |  SIZE   |  DESC                                                  |
|----------|---------|--------------------------------------------------------|
| SIG_HDR  | 1 Byte  |  The signature header (0xF0)                           |
|----------|---------|--------------------------------------------------------|
|   HDR    | 1 Byte  |  The message type                                      |
|----------|---------|--------------------------------------------------------|
|   SIZE   | 2 Bytes |  The length of the following chunk of data             |
|          |         |  (in network byte order)                               |
|----------|---------|--------------------------------------------------------|
|   DATA   | N Bytes |  The actual chunk of data                              |
|----------|---------|--------------------------------------------------------|
|   EOR    | 2 Bytes |  End Of Record (0x00, 0x00)                            |
|----------|---------|--------------------------------------------------------|
|   RSEP   | 1 Bytes |  Record Separator (0x80)                               |
|----------|---------|--------------------------------------------------------|
|   SIZE   | 2 Bytes |                                                        |
|----------|---------|--------------------------------------------------------|
|   DATA   | N Bytes |                                                        |
|----------|---------|--------------------------------------------------------|
|   RSEP   | 1 Bytes |  Record Separator (0x80)                               |
|----------|---------|--------------------------------------------------------|
|   SIZE   | 2 Bytes |  Size of the ttl record (must be 4 == 0x00,0x04)       |
|----------|---------|--------------------------------------------------------|
|   TTL    | 4 Bytes |  ttl in seconds (uint32_t in network byte order)       |
|----------|---------|--------------------------------------------------------|
|   EOR    | 2 Bytes |  End Of Record (0x00, 0x00)                            |
|----------|---------|--------------------------------------------------------|
|   EOM    | 1 Byte  |  Message Terminator (0x00)                             |
|----------|---------|--------------------------------------------------------|
|   SIG    | 8 Bytes |  SIPHASH digest computed on the message                |
|          |         |  using the shared secret                               |
-------------------------------------------------------------------------------



A more complex message with 2 records but not fitting in a single chunk would 
look like (this time without the ttl record):

===============================================================================
|  FIELD   |  SIZE   |  DESC                                                  |
|----------|---------|--------------------------------------------------------|
| SIG_HDR  | 1 Byte  |  The signature header (0xF0)                           |
|----------|---------|--------------------------------------------------------|
|   HDR    | 1 Byte  |  The message type                                      |
|----------|---------|--------------------------------------------------------|
|   SIZE   | 2 Bytes |  The length of the following chunk of data             |
|          |         |  (in network byte order)                               |
|----------|---------|--------------------------------------------------------|
|   DATA   | N Bytes |  The actual chunk of data                              |
|----------|---------|--------------------------------------------------------|
|    .     |   .     |                          .                             |
|----------|---------|--------------------------------------------------------|
|    .     |   .     |                          .                             |
|----------|---------|--------------------------------------------------------|
|    .     |   .     |                          .                             |
|----------|---------|--------------------------------------------------------|
|   SIZE   | 2 Bytes |                                                        |
|----------|---------|--------------------------------------------------------|
|   DATA   | N Bytes |                                                        |
|----------|---------|--------------------------------------------------------|
|   EOR    | 2 Bytes |  End Of Record (0x00, 0x00)                            |
|----------|---------|--------------------------------------------------------|
|   RSEP   | 1 Bytes |  Record Separator (0x80)                               |
|----------|---------|--------------------------------------------------------|
|   SIZE   | 2 Bytes |                                                        |
|----------|---------|--------------------------------------------------------|
|   DATA   | N Bytes |                                                        |
|----------|---------|--------------------------------------------------------|
|    .     |   .     |                          .                             |
|----------|---------|--------------------------------------------------------|
|    .     |   .     |                          .                             |
|----------|---------|--------------------------------------------------------|
|    .     |   .     |                          .                             |
|----------|---------|--------------------------------------------------------|
|   SIZE   | 2 Bytes |                                                        |
|----------|---------|--------------------------------------------------------|
|   DATA   | N Bytes |                                                        |
|----------|---------|--------------------------------------------------------|
|   EOR    | 2 Bytes |  End Of Record (0x00, 0x00)                            |
|----------|---------|--------------------------------------------------------|
|   EOM    | 1 Byte  |  Message Terminator (0x00)                             |
|----------|---------|--------------------------------------------------------|
|   SIG    | 8 Bytes |  SIPHASH digest computed on the message                |
|          |         |  using the shared secret                               |
-------------------------------------------------------------------------------

NOTE: The protocol allows for an unlimited amount of records, even though 
      only 2 records have a practical use since no implemented message 
      makes use of more than 2 (apart SET, which requires both key and value,
      all other request types require only one record to be provided)


More Examples (The signature header and postfix are omitted for simplicity)

A GET message for the key FOO (hex sequence: 0x46 0x4f 0x4f) would look like:

<01><00><03><46><4f><4f><00><00><00>

-------------------------------------------------------------------------------

A SET message for the key FOO (hex sequence: 0x46 0x4f 0x4f)
assigning the value TEST (hex sequence: 0x54 0x45 0x53 0x54) would look like:

<02><00><03><46><4f><4f><00><00><80><00><04><54><45><53><54><00><00><00>

-------------------------------------------------------------------------------

A DEL message for the FOO would look exactly like a GET message but with a
different HDR value :

<03><00><03><46><4f><4f><00><00><00>

An EVI message would look exactly like a DEL message but with an HDR byte equal
to 0x04

-------------------------------------------------------------------------------

A RES message containing a value "OK" (0x4f 0x4b) would look like:

<99><00><02><4f><4b><00><00><00>

-------------------------------------------------------------------------------

A RES with an empty value (for instance if querying a not-existing key):

<99><00><00><00>

-------------------------------------------------------------------------------

NOTES:


A signed message MUST be wrapped with a SIG_HDR prefix and a SIG postfix.
The SIG postfix is a siphash digest computed using a shared secret and the
complete message (obviously excluding the signature itself)

The signature is optional and can be omitted.

Responses to 'GET' requests will return the value for the requested key
if found, an empty value otherwise

Responses to 'SET', 'DEL' and 'EVI' requests will return either the string
'OK' or 'ERR' depending on the status of the operation

The actual implementation serves only one request per connection, so
implementing the protocol you should expect the peer to close its socket
just after serving the response (and it may close
its reading part of the socket just after reading exactly one complete request)
